Section 7 : Forms

- Introduction
Login form, Register form, Add/Edit movies, Search box

- Building a Bootstrap form
 * Create loginForm.jsx
create LoginForm cc with h1
Add route in App.js for /login
In navBar.jsx add NavLink for Login
In bootstrap form, div.form-group groups label and corresponding input,
also input has form-control class
In loginForm
Wrap h1 with div
Create form as
form>(div.form-group>label+input.form-control)*2
remove action attribute
Set labels : Username, Password
Set for(htmlFor) and id attribute : username, password
Add primary Login button

- Handling Form Submission
* Preventing full page reload
Add onSubmit attribute to form
Create method handleSubmit with e argument
add statement e.preventDefault(); then do something
Set onSubmit to this method

- Refs
* In react we don't use document object directly
* Getting value of input field
in component define Refs object property username = React.createRef()
in input element set ref attribute to this.username
when sumbitting form const username = this.username.current.value
* current field of Refs object returns DOM element
* We don't use Refs for building forms.
* We use Refs for DOM libraries, animation etc.

- Controlled Elements
* Similar to Controlled component
* Add state property to LoginForm as
state = { account : {username: "", password: ""}}
* Removing state of input field / converting to controlled element
add value attribute to input with this.state.account.username
* Changing state on change events
add onChange attribute to input with this.handleChange
create method handleChange with args (e)
set typed value from e.currentTarget.value to username

- Handling Multiple Inputs
* Setting property dynamically
use bracket notation : account[input.name]
add name attribute to input with username value
* Do destructuring in handleChange as
(e) becomes ({currentTarget:input})

- Common errors
* if value attribute of element has value undefined/null,
then it becomes uncontrolled element
* Initialize variables used for value attribute at onset.

- Extracting a Reusable Input
* Create input.jsx in common folder
Using name, label, value, onChange

- Validation
* Add errors object property in state
if input fields has error then it's name will be added to errors with error string
* Call validate method in handleSubmit, and add errors to state accordingly
* validate method will return empty object on no errors.

- Displaying Validation Errors
* In input.jsx
After input field add div.alert.alert-danger with error conditionally
Add error to input.jsx props
* In loginForm
In Input add error={errors.username}
In handleSubmit setState set errors to empty object on null

- Validation on Change
* In handleChange do validation as
get errorMessage for input using validateProperty method
set errorMessage for input in errors if there is error
else delete key in errors for the input
* Create validateProperty method
args : input OR {name, value}
check for input name, then check it's value
then return validation message.

- JOI
* Install : npm i joi-browser@13.4
* We define schema object, and it has properties and their validation requirement
* Import Joi from 'joi-browser'
* Define schema in LoginForm as
schema = {
    username: Joi.string().required().label("Username"),
    password: Joi.string().required().label("Password"),
}
* Validate as : Joi.validate(objectToValidate, schema, {abortEarly: false})

- Validate a Form Using Joi
* Mapping result.error.details array into object
* Rewriting validate method
return when result.error is falsy
else iterate over error.details as
errors[item.path[0]] = item.message

- Validate a Field Using Joi
* Computed properties in ES6
setting key names dynamically : { [varName] : val}
* Modifying validateProperty method
Create obj variable as obj = { [name] : value }
Create sub-schema as schema = { [name] : this.schema[name]}
Return result.error.details[0].message if there is error else null

- Disabling the Submit button
* Add attribute disabled={this.validate()} to button

- Extracting a Reusable Form
* In LoginForm rename account to data
* In common folder create form.jsx
In state object add data and errors with empty object
move validate and validateProperty to Form
import Joi in Form
Remove render method from Form
In LoginForm for handleSubmit for statements after
validation move them to new function doSubmit.
Add doSubmit call to handleSubmit
Move handleSubmit to Form class
Move handleChange to Form Class
* Make LoginForm extend Form

- Extracting Helper Rendering Methods
* Helper method for submit button
arg: label, return the markup
* Helper method for input
arg: name, label, type
also add type attribute to input with default value 'text'
apply type dynamically in input.jsx
* Using rest operator in input.jsx
In props destructuring store remaining props in ...rest
In input use {...rest} for applying remaining props as attributes

- Excercise 1 - Register Form
* Create route for Register in App.js
* Add link to NavBar
* Create RegisterForm extending Form

- Excercise 2 - Movie Form
* Create mapViewToModel function to map server data to view data.
completed

- Exercise 3 - Search Movies
* Using .toLowerCase and .startsWith
completed
---------------------------------------------------------------

Section 8 : Calling Backend Services

- Introduction
* Using fake backend from jsonplaceholder.typicode.com

- Http Clients
* 3 clients : Fetch API, jQuery AJAX, Axios
* Installing axios : npm i axios@0.18

- Getting Data
* In App.js
import axios from 'axios'
In componentDidMount make request as
axios.get('<typicode>/posts')
it return promise and needed to await
Set state of posts from data of response
* Promise
holds result of async operation
state goes from pending to resolved or rejected
[[PromiseState]] and [[PromiseValue]] are internal property
Response object has: config, data, headers, reqeust, status, statusText
Getting result :
old way - promise.then()
new way - using await, function should be decorated with async

- Creating Data
* In handleAdd
create post object
send using : axios.post(url, object)
decorate func : handleAdd = asyn() =>...
log result to console
Append it at beginning of posts

- Lifecycle of a Request
* Options request method
When frontend and backend are on different domain
Browser always sends Options request for security

- Updating Data
* In handleUpdate
change post title - post.title = "value"
Update some properties - axios.patch
Update all properties - axios.put
args - urlWithId, dataObject
await the request
log the response data
Update the UI : 
const posts = clone of this.state.posts
posts[indexOfpost] = clone of post
setState with posts

- Deleting data
* In handleDelete
await axios.delete(urlWithId)
remove post from posts in state

- Optimistic vs Pessimistic Updates
* Pessimistic : when update happens after successful of CRUD Op
* Optimistic : update happens first then CRUD happens as
storing original state
updating first : this.setState({posts})
calling server CRUD op : await axios.delete etc.
when fails using try catch: this.setState({posts:original})

- Expected vs Unexpected Errors
* Expected
Client errors : 40X errors
Display a specific error message
* Unexpected
Technically shouldn't happen normally
e.g. - Network down, server down, database down, bug
Log them
Display a generic and friendly error message
* exception object in try/catch has
ex.request : set when successfully submit to server,
otherwise null
ex.response : set when response received successfully,
and not set network/server down
* Check for 404
if (ex.response && ex.response.status === 404) display error
Other non-considered errors will be unexpected errors
Log the unexpected errors

- Handling Unexpected Errors Globally
* Using interceptor as
At file beginning after imports add
axios.interceptors.response.use(successFunc, errorFunc)
succssFunc will be null
errorFunc => {
    Log "interceptor called"
    expectedError = error.response && 400 =< error.response.status < 500
    if not expectedError : then log, and alert
    return rejected Promise.reject(error)
}
* try/catch is needed when
We need to do something specific on failure as
check for expected error
undo the UI changes made

- Extracting a Reusable Http Service
* Axios will be hidden behing new module
So, axios can be replaced with other library
* Create file src/services/httpService.js
* In httpService.js
import axios
Move interceptor code here
remove interceptor code from App.js
export default object as
{get:axios.get, post:axios.post, put:axios.put, delete:axios.delete}
* In App.js
import http from httpService
Replace axios with http

- Extracting a Config Module
* Putting apiEndpoint url out of App.js
Create config.json in src folder
add {"apiEndpoint":"url"}
* In App.js
import config from "./config.json"
Prefix apiEndpoint with "config."

- Displaying Toast Notifications
* install toastify
npm i react-toastify@4.1
* In App.js
import {ToastContainer} from 'react-toastify'
import 'react-toastify/dist/ReactToastify.css'
Add <ToastContainer /> at beginning of App component
* In httpService
import {toast} from 'react-toastify'
Replace alert with toast.error

- Logging Errors
* Using sentry
install as : npm i raven-js@3.26.4
* In index.js
import Raven from 'raven-js'
Add following
Raven.config("<dsn value>", {
    releast: '0-0-0',
    environment: 'development-text',
}).install()
* DSN is found at :
Projects > <projectname> > Settings > Client keys(DSN)
* In httpService
import Raven form 'raven-js'
Replace console.log with Raven.captureException(error)

- Extracting a Logger Service
* Create file src/services/logService.js
import Raven from 'raven-js'
Create function init
Move Raven.config statement here
Create function log(error)
add Raven.captureException(error)
Export default as {init, log}
* In index.js
import logService as logger
Initialize as logger.init()
* In httpService.js
import logService
Replace Raven.captureException with logger.log

- Vidly Backend
* Install MongoDB

- Installing MongoDB
TODO

- Setting Up the Node Backend
* Clone git repo
github.com/mosh-hamedani/vidly-api-node
* Install dependencies : npm i
* Seed database : node seed.js
* Start web server : node index.js
localhost:3900/api/genres

- Disabling Authentication

- Exercise-Connect Movies Page to the Backend

- Adding Http and Log Services
* Copy httpService and logService in service folder
* Install axios and toastify ; axios@0.18.0 react-toastify@4.1.0
* In App.js add Toast container as
import {ToastContainer} from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';
In render method before NavBar add <ToastContainer />

- Replacing FakeMovieService
* Implementing undo in Optimistic update in handleDelete in movies.jsx
import {toast} from 'react-toastify'
const originalMovies = this.state.movies;
const movies = originalMovies.filter(m => m.id != movie.id)
this.setState({movies})
try {
    await deleteMovie(movie.id)
}
catch (ex) {
    if (ex.response && ex.response.status === 404)
      toast.error('This movie has already been deleted.')
    this.setState({movies: originalMovies})
}

- Populating the Form
* Redirecting to Not found in conponentDidMount
try {
    const movie = await getMovie(movieId);
    this.setState({ data: this.mapViewToModel(movie) });
} catch (ex) {
    if (ex.response && ex.response.status === 404)
    this.props.history.replace("/not-found");
}

- Refactoring
* In componentDidMount in movieForm.jsx
Divide it into populateGenre and populateMovie
---------------------------------------------------------------

Section 9 : Authentication and Authorization

- Introduction
* JSON Web Tokens
* Calling Protected APIs
* Showing / Hiding elements
* Protecting Routes

- Registering a New User
* Check backend endpoints using postman

- Submitting the Registration Form
* Create a new service userService.js
Register, Delete, Getinfo
import http from './httpService'
import {apiUrl} from "../config.json";

const apiEndpoint = apiUrl + "/auth/users/";

export function register(user) {
  return http.post(apiEndpoint, {
    email: user.username,
    username: user.name,
    password: password
  }
}
* In RegisterForm
import * as userService from '../services/userService'
In doSubmit method
await userService.register(this.state.data);
mark this function as async

- Handling Registration Errors
* In registerForm in doSubmit
wrap register call with try catch
try {...}
catch (ex) {
  if (ex.response && ex.response.status === 400){
    const errors = {...this.state.errors};
    errors.name = ex.response.data.username
    errors.username = ex.response.data.email
    this.setState({errors})
  }
} 

- Logging in a User
* Check backend login endpoint using postman

- Submitting the Login Form
* Create a new service authService.js
Login and Logout
import http, apiUrl
const apiEndpoint = apiUrl + "/auth/jwt/create/"

export function login(username, password) {
  return http.post(apiEndpoint, {username, password})
}
* In LoginForm
import {login} from '../services/authService';
In doSubmit
const {data} = this.state;
await login(data.username, data.password)
Mark function as async

- Handling Login Errors
* In LoginForm in doSubmit
wrap login call with try catch
try {...}
catch (ex) {
  if (ex.response && ex.response.status === 400) {
    const errors = {...this.state.errrors}
    errors.username = ex.response.data.username
    errors.password = ex.response.data.password
    if (ex.response.data.detail)
      errors.username = ex.response.data.detail
    this.setState({errors})
  }
}

- Storing the JWT
* Browser has small database called localstorage
key value pairs can be stored
* In LoginForm in doSubmit
const {data: jwt} = await login(...
localStorage.setItem('token', jwt)
* In Chrome dev tools > Application 
Storage > Local Storage
In website will have stored value as key value pair
* Redirect user to home page
this.props.history.push('/');
* How I did storing
const {data:result} = await login(...
localStorage.setItem('access', result.access)
localStorage.setItem('refresh', result.refresh)

- Logging in the User upon Registration
* In RegisterForm in doSubmit method
store register response
const response = await userService.register(...
localStorage.setItem('token', response.headers['x-auth-token'])
this.props.history.push("/");
* How I did it
> Returning access and refresh token in headers in drf backend
Create a new middleware in project
in core folder in middleware.py
from rest_framework_simplejwt.tokens import RefreshToken
from .models import User
Create class CoreMiddleware
In __init__ method
arg : get_response
self.get_response = get_response
In __call__ method
arg : request
response = self.get_response(request)
if request.method == 'POST and
   request.path == '/auth/users/' and
   response.status_code == 201:
   id = response.data.get('id')
   if id:
      user = User.objects.get(pk=id)
      tokens = RefreshToken.for_user(user)
      response['x-refresh-token'] = tokens
      response['x-access-token'] = tokens.access_token
      response['access-control-expose-headers'] = 'x-access-token, x-refresh-token'
   return response
Add following middleware in settings.py/MIDDLEWARE
core.middleware.CoreMiddleware
> In RegisterForm doSubmit method
localStorage.setItem('access', response.headers['x-access-token'])
localStorage.setItem('refresh', response.headers['x-refresh-token'])
      
- JSON Web Tokens (JWT)
* Has 3 parts
Header - alg, typ
Payload - properties object
Signature - Digital signature, generated based on
header, payload and secret
* In Django RF storing username and email in JWT
> In core/serializers.py create serializer as
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
class CustomTokenObtainPairSerializer
extends : TokenObtainPairSerializer
Add class method as :
@classmethod
def get_token(cls, user):
  token = super().get_token(user)
  token['username'] = user.username
  token['email'] = user.email
  return token
> In core/views.py create view as :
from rest_framework_simplejwt.views import TokenObtainPairView
from .serializers import CustomTokenObtainPairSerializer
class CustomTokenObtainPairView
extends : TokenObtainPairView
Add fields :
serializer_class = CustomTokenObtainPairSerializer
token_obtain_pair = TokenObtainPairView.as_view()
> In core/urls.py define urls as
from django.urls import re_path
from rest_framework_simplejwt import views
from .views import CustomTokenObtainPairView
urlpatterns = [
    re_path(r"^jwt/create/?", CustomTokenObtainPairView.as_view(), name="jwt-create"),
    re_path(r"^jwt/refresh/?", views.TokenRefreshView.as_view(), name="jwt-refresh"),
    re_path(r"^jwt/verify/?", views.TokenVerifyView.as_view(), name="jwt-verify"),
]
> In primary urls.py replace as
'djoser.urls.jwt' to 'core.urls'
> In core/middleware.py also make it add details to payload as
tokens['username'] = user.username
tokens['email'] = user.email

- Getting the Current User
* Install jwt-decode : npm i jwt-decode@2.2.0
* In App.js in App componnet
import jwtDecode from "jwt-decode"
state = {};
in componentDidMount() 
try{
const jwt = localStorage.getItem('access')
const data = jwtDecode(jwt)
const user = {username:data.username, id:data.user_id, email:data.email}
this.setState({user})
} catch (ex) {}
In render method
Add prop to NavBar : user={this.state.user}

- Showing the Current User on NavBar
* In NavBar get user prop as args as ({user})
* Render Login and Register conditionally
{!user && <React.Fragment> 
  ...Login and Register element...
</React.Fragment>}
* Render Logout and Username conditionally
After previous element add
{user && <React.Fragment>
 <NavLink ... to="/profile">{user.name}...
 <NavLink ... to="/logout">Logout...
</React.Fragment>}
* Full page reload : 
In loginForm and registerForm in doSubmit after setting token
window.location = '/';

- Logging out a User
* In components folder add logout.jsx
imrc
cc Logout
In render method return null
In cdm : 
localStorage.removeItem('access')
localStorage.removeItem('refresh')
window.location = '/'
* In App.js
After login route add
<Route path="/logout" component={Logout} />

- Refactoring
* In authService.js add
> In login function
const {data:jwt} = await http...
localStorage.setItem("token",jwt)
mark function as async
> Create logout function and export it
localStorage.removeItem('token')
> Create getCurrentUser function and export it
import jwtDecode from "jwt-decode"
Move try catch from App.js cdm here
return user in try and return null in catch
> Create loginWithJwt(jwt) function and export it
localStorage.setItem("token", jwt)
> Export default object with all functions
* In loginForm in doSubmit
Remove localStorage statement
* In Logout in cdm
import auth from '../services/authService'
Remove localStorage statement
auth.logout()
* In App.js in cdm
import auth from '/services/authService'
Remove localStorage and jwtDecode statement
const user = auth.getCurrentUser()
this.setState({user})
* In registerForm in doSubmit
import auth from "../services/authService"
Remove localStorage statement
auth.loginWithJwt(response.headers["x-auth-token"])

- Calling Protected  API Endpoints
* Enable authentication in backend
* In httpService add authorization header to request
common : for all
post : for post
After import
import auth from './authService'
axios.defaults.headers.common['Authorization'] = auth.getAuthorizationToken()
* In authService
Create function getAuthorizationToken
accessToken = localStorage.getItem("access")
if (accessToken) return `JWT ${accessToken}`
else return null

- Fixing Bi-directional Dependencies
* http module is essential than auth
* In httpService
remove auth import
Replace auth.getJwt with function
export function setAuthorizationToken(token) {
    axios.defaults.headers.common['Authorization'] = token;
}
* In authService
After imports
http.setAuthorizationToken(getAuthrizationToken())

- Authorization
* In django in CustomTokenObtainPairSerializer
add token for isAdmin as
token['isAdmin'] = user.is_staff

- Showing or Hiding Elements based on the User
* In App.js
Pass user object in Movies component in route as
<Route ... render={props => <Movies {...props} user={user}/>} />
* In Movies component
In render
const {user} = this.props
Wrap New movie button with
{user && ..button...}

- Protecting Routes
* In App.js
Change route for MovieForm to
<Route path=... 
render={props => {
  if(!user) return <Redirect to="/login" />
  return <MovieForm {...props} />
}}

-----------------------
Section 9 Vid 19 : Protecting Routes - completed

Shortcuts
1. Wrapping html with other html
Select the text > Shift+Ctrl+P > wrap with abbreviation > enter >
type tag/zen coding (div.container)

