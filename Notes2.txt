Section 7 : Forms

- Introduction
Login form, Register form, Add/Edit movies, Search box

- Building a Bootstrap form
 * Create loginForm.jsx
create LoginForm cc with h1
Add route in App.js for /login
In navBar.jsx add NavLink for Login
In bootstrap form, div.form-group groups label and corresponding input,
also input has form-control class
In loginForm
Wrap h1 with div
Create form as
form>(div.form-group>label+input.form-control)*2
remove action attribute
Set labels : Username, Password
Set for(htmlFor) and id attribute : username, password
Add primary Login button

- Handling Form Submission
* Preventing full page reload
Add onSubmit attribute to form
Create method handleSubmit with e argument
add statement e.preventDefault(); then do something
Set onSubmit to this method

- Refs
* In react we don't use document object directly
* Getting value of input field
in component define Refs object property username = React.createRef()
in input element set ref attribute to this.username
when sumbitting form const username = this.username.current.value
* current field of Refs object returns DOM element
* We don't use Refs for building forms.
* We use Refs for DOM libraries, animation etc.

- Controlled Elements
* Similar to Controlled component
* Add state property to LoginForm as
state = { account : {username: "", password: ""}}
* Removing state of input field / converting to controlled element
add value attribute to input with this.state.account.username
* Changing state on change events
add onChange attribute to input with this.handleChange
create method handleChange with args (e)
set typed value from e.currentTarget.value to username

- Handling Multiple Inputs
* Setting property dynamically
use bracket notation : account[input.name]
add name attribute to input with username value
* Do destructuring in handleChange as
(e) becomes ({currentTarget:input})

- Common errors
* if value attribute of element has value undefined/null,
then it becomes uncontrolled element
* Initialize variables used for value attribute at onset.

- Extracting a Reusable Input
* Create input.jsx in common folder
Using name, label, value, onChange

- Validation
* Add errors object property in state
if input fields has error then it's name will be added to errors with error string
* Call validate method in handleSubmit, and add errors to state accordingly
* validate method will return empty object on no errors.

- Displaying Validation Errors
* In input.jsx
After input field add div.alert.alert-danger with error conditionally
Add error to input.jsx props
* In loginForm
In Input add error={errors.username}
In handleSubmit setState set errors to empty object on null

- Validation on Change
* In handleChange do validation as
get errorMessage for input using validateProperty method
set errorMessage for input in errors if there is error
else delete key in errors for the input
* Create validateProperty method
args : input OR {name, value}
check for input name, then check it's value
then return validation message.

- JOI
* Install : npm i joi-browser@13.4
* We define schema object, and it has properties and their validation requirement
* Import Joi from 'joi-browser'
* Define schema in LoginForm as
schema = {
    username: Joi.string().required().label("Username"),
    password: Joi.string().required().label("Password"),
}
* Validate as : Joi.validate(objectToValidate, schema, {abortEarly: false})

- Validate a Form Using Joi
* Mapping result.error.details array into object
* Rewriting validate method
return when result.error is falsy
else iterate over error.details as
errors[item.path[0]] = item.message

- Validate a Field Using Joi
* Computed properties in ES6
setting key names dynamically : { [varName] : val}
* Modifying validateProperty method
Create obj variable as obj = { [name] : value }
Create sub-schema as schema = { [name] : this.schema[name]}
Return result.error.details[0].message if there is error else null

- Disabling the Submit button
* Add attribute disabled={this.validate()} to button

- Extracting a Reusable Form
* In LoginForm rename account to data
* In common folder create form.jsx
In state object add data and errors with empty object
move validate and validateProperty to Form
import Joi in Form
Remove render method from Form
In LoginForm for handleSubmit for statements after
validation move them to new function doSubmit.
Add doSubmit call to handleSubmit
Move handleSubmit to Form class
Move handleChange to Form Class
* Make LoginForm extend Form

- Extracting Helper Rendering Methods
* Helper method for submit button
arg: label, return the markup
* Helper method for input
arg: name, label, type
also add type attribute to input with default value 'text'
apply type dynamically in input.jsx
* Using rest operator in input.jsx
In props destructuring store remaining props in ...rest
In input use {...rest} for applying remaining props as attributes

- Excercise 1 - Register Form
* Create route for Register in App.js
* Add link to NavBar
* Create RegisterForm extending Form

- Excercise 2 - Movie Form
* Create mapViewToModel function to map server data to view data.
completed

- Exercise 3 - Search Movies
* Using .toLowerCase and .startsWith
completed
---------------------------------------------------------------

Section 8 : Calling Backend Services

- Introduction
* Using fake backend from jsonplaceholder.typicode.com

- Http Clients
* 3 clients : Fetch API, jQuery AJAX, Axios
* Installing axios : npm i axios@0.18

- Getting Data
* In App.js
import axios from 'axios'
In componentDidMount make request as
axios.get('<typicode>/posts')
it return promise and needed to await
Set state of posts from data of response
* Promise
holds result of async operation
state goes from pending to resolved or rejected
[[PromiseState]] and [[PromiseValue]] are internal property
Response object has: config, data, headers, reqeust, status, statusText
Getting result :
old way - promise.then()
new way - using await, function should be decorated with async

- Creating Data
* In handleAdd
create post object
send using : axios.post(url, object)
decorate func : handleAdd = asyn() =>...
log result to console
Append it at beginning of posts

- Lifecycle of a Request
* Options request method
When frontend and backend are on different domain
Browser always sends Options request for security

- Updating Data
* In handleUpdate
change post title - post.title = "value"
Update some properties - axios.patch
Update all properties - axios.put
args - urlWithId, dataObject
await the request
log the response data
Update the UI : 
const posts = clone of this.state.posts
posts[indexOfpost] = clone of post
setState with posts

- Deleting data
* In handleDelete
await axios.delete(urlWithId)
remove post from posts in state

- Optimistic vs Pessimistic Updates
* Pessimistic : when update happens after successful of CRUD Op
* Optimistic : update happens first then CRUD happens as
storing original state
updating first : this.setState({posts})
calling server CRUD op : await axios.delete etc.
when fails using try catch: this.setState({posts:original})

- Expected vs Unexpected Errors
* Expected
Client errors : 40X errors
Display a specific error message
* Unexpected
Technically shouldn't happen normally
e.g. - Network down, server down, database down, bug
Log them
Display a generic and friendly error message
* exception object in try/catch has
ex.request : set when successfully submit to server,
otherwise null
ex.response : set when response received successfully,
and not set network/server down
* Check for 404
if (ex.response && ex.response.status === 404) display error
Other non-considered errors will be unexpected errors
Log the unexpected errors

- Handling Unexpected Errors Globally
* Using interceptor as
At file beginning after imports add
axios.interceptors.response.use(successFunc, errorFunc)
succssFunc will be null
errorFunc => {
    Log "interceptor called"
    expectedError = error.response && 400 =< error.response.status < 500
    if not expectedError : then log, and alert
    return rejected Promise.reject(error)
}
* try/catch is needed when
We need to do something specific on failure as
check for expected error
undo the UI changes made

- Extracting a Reusable Http Service
* Axios will be hidden behing new module
So, axios can be replaced with other library
* Create file src/services/httpService.js
* In httpService.js
import axios
Move interceptor code here
remove interceptor code from App.js
export default object as
{get:axios.get, post:axios.post, put:axios.put, delete:axios.delete}
* In App.js
import http from httpService
Replace axios with http

- Extracting a Config Module
* Putting apiEndpoint url out of App.js
Create config.json in src folder
add {"apiEndpoint":"url"}
* In App.js
import config from "./config.json"
Prefix apiEndpoint with "config."

- Displaying Toast Notifications
* install toastify
npm i react-toastify@4.1
* In App.js
import {ToastContainer} from 'react-toastify'
import 'react-toastify/dist/ReactToastify.css'
Add <ToastContainer /> at beginning of App component
* In httpService
import {toast} from 'react-toastify'
Replace alert with toast.error

- Logging Errors
* Using sentry
install as : npm i raven-js@3.26.4
* In index.js
import Raven from 'raven-js'
Add following
Raven.config("<dsn value>", {
    releast: '0-0-0',
    environment: 'development-text',
}).install()
* DSN is found at :
Projects > <projectname> > Settings > Client keys(DSN)
* In httpService
import Raven form 'raven-js'
Replace console.log with Raven.captureException(error)

- Extracting a Logger Service
* Create file src/services/logService.js
import Raven from 'raven-js'
Create function init
Move Raven.config statement here
Create function log(error)
add Raven.captureException(error)
Export default as {init, log}
* In index.js
import logService as logger
Initialize as logger.init()
* In httpService.js
import logService
Replace Raven.captureException with logger.log

- Vidly Backend
* Install MongoDB

- Installing MongoDB
TODO

- Setting Up the Node Backend
* Clone git repo
github.com/mosh-hamedani/vidly-api-node
* Install dependencies : npm i
* Seed database : node seed.js
* Start web server : node index.js
localhost:3900/api/genres

- Disabling Authentication

- Exercise-Connect Movies Page to the Backend

- Adding Http and Log Services
* Copy httpService and logService in service folder
* Install axios and toastify ; axios@0.18.0 react-toastify@4.1.0
* In App.js add Toast container as
import {ToastContainer} from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';
In render method before NavBar add <ToastContainer />

- Replacing FakeMovieService
* Implementing undo in Optimistic update in handleDelete in movies.jsx
import {toast} from 'react-toastify'
const originalMovies = this.state.movies;
const movies = originalMovies.filter(m => m.id != movie.id)
this.setState({movies})
try {
    await deleteMovie(movie.id)
}
catch (ex) {
    if (ex.response && ex.response.status === 404)
      toast.error('This movie has already been deleted.')
    this.setState({movies: originalMovies})
}


-----------------------
Shortcuts
1. Wrapping html with other html
Select the text > Shift+Ctrl+P > wrap with abbreviation > enter >
type tag/zen coding (div.container)
